---
title: 2025 oscamp blog of hailong
date: 2025-06-20 12:43:27
tags:
    - author:hailongxu
---



# 2025-07-26 14:36:00

### 2025-7-25
分析了下M-tour中的trap注册过程，`#[register_trap_handler(SYSCALL)]`，把这个handle函数放到了一个指定的数据段中，形成一个数组，通过数组进行访问的

### 2025-7-25
m做了部分试验：从模块原理上，在使用层面上进行理解的,userspace，userstack，spawn_user_task.

### 2025-7-24
试验了u部分的app，但是u_7_0和u_8_0要等很久不知道为啥，大约98秒？加上LOG=debug，300秒后，也没运行出来

### 2025-7-23
复习了2025年春季的os的组件系统化的课，
1. 虚拟机如何启动和退出，虚拟机的模态之间的关系
2. 虚拟机内存在hypervisor和gustos的物理空间关系，分开管理的。
3. 疑问：H模式和S模式能共存吗？
4. 中断注入的方式，hypervisor注入到guest后，这步如何实现的


---


# 2025-06-20 03:06:00

## 第一阶段 rust基础
rustlings比较顺利，已关注rust好几年了，也一直跟进rust的发展和变化，用了大概几天的时间突击完成

## 第二阶段 rcore
这是我第一次接触操作系统，印象还都停留在原来的书本上，概念上，都是理论，没有真正接触操作系统是什么样的，所以，这个机会能让我了解探究操作系统内部真正的原理和运行逻辑，解开我心中的多年的疑惑，很是开心到起飞。

总体印象最深的就是操作系统内核是以什么形态存在的，上下文如何切换，进程空间如何形成，页表是如何实现的，跳板页又是怎么回事

## 第三阶段 ArceOS
这个和我预期不一样，没有沿着rcore继续走，这是一个全新的设计，一时间，有点慌乱，不能和rcore相关的思路很自然的顺承下来，显然这个更具有前瞻性，为此我也花了好多时间来梳理这个逻辑和rcore都关联起来。这个模块化设计的理念很突出，相互之间的关联及细节，需要仔细的研读和体会。

## 第三阶段的具体case
### color
对println!() 把颜色表示直接加入后，可以显示颜色，
如在当前文件写了一个宏print_with_color!，让后让println!去去调用此宏，就得不到正确结果，提示找不到这个宏，查了资料，和 $crate有关，宏的暴露方式有关，引用路径，由于时间关系，后面调研

### HashMap
开始的时候，从rust官方移植，这个太痛苦了，依赖太多了，最后放弃。
自己写个简单的，只是利用了官方的
use core::hash::Hasher;
use core::hash::Hash;
这两个hash算法，主体采用了最简单的线性插入算法

### bumpallocator
需要仔细理解题意和上下文，思路选用：
申请一直从可用空间起始向前申请，
释放如果全部的空间都释放了，就把下一个可用空间调整到开始

### rename
采用递归的方式，一层一层的先找到所在当前目录
增加当前目录的，更改命名的方法，查找相应的文件，删除后，再插入一个，因为当前存储使用的是BtreeMap，不能更改index

### hv
这个耗费了我好多时间，主要是因为运行例程会卡住，后来发现可能是qemu的版本问题，升级到9.2后，还是一样卡住，当时环境为windows11，wsl2，卡在这里，不同的情况卡的还不一样：
```bash
Write file 'payload/skernel2/skernel2' into disk.img
```
最后没有办法，找一台空闲机器，实在不行，我就安装裸机linux系统，所以先尝试装了另一种虚拟机，virtualbox7.18，也花了些时间，配置好环境后，默认的qemu为6.x时，还是会出错，不过不是卡主的问题，是会触发异常访问，升级到9.2.x后，按照预期执行了，难道说，wsl2在某些情况就是不行，我真是难过。

之后遇到提交github，出错，musl.cc被block，
>下载不下来：
    wget https://musl.cc/riscv64-linux-musl-cross.tgz  

下载不下来，终于等来了替代方案
>    wget https://musl.cc.timfish.dev/riscv64-linux-musl-cross.tgz  
最后，终于得以解决

### sys_mmap
参数和返回值我理解出现偏差，
```rust
fn sys_mmap(
    addr: *mut usize,
    length: usize,
    prot: i32,
    flags: i32,
    fd: i32,
    _offset: isize,
) -> isize
```
参数addr为0时要特别注意，需要寻找一空间，还有地址和size的对齐。返回值，当开始时认为0是成功，为负时，返回失败原因，后来再三确认失败返回0，成功返回地址，isize作为地址返回，有点不符合直觉？

## Next
期待第四阶段